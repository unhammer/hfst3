
  /** \page VersionDifferences.html 

      <b>This page is still under construction...</b>

      If you need documentation on HFST version 2, you find it 
      <a href="http://hfst.sourceforge.net/hfst2/index.html">here</a>.
      The page is no longer updated and it is recommended to update
      to version 3.0.

      Some changes from version 2 to 3:

      <table>
      <tr>
      <th>HFST version 2</th>
      <th>HFST version 3</th>
      </tr>
      <tr>  
      <td>Namespaces HFST and HWFST</td>
      <td>Namespace hfst and an ImplementationType argument</td>
      </tr>
      <tr>
      <td>KeyLayer and SymbolLayer</td>
      <td>Functions take a string argument, string-to-number mapping
      is done internally and automatically</td>
      </tr>
      <tr>
      <td>TransducerLayer, Rule Layer, CoreExtensionLayer</td>	
      <td>HfstTransducer, namespace hfst::rules, class HfstTransitionGraph</td>
      </tr>
      <tr>
      <td>Functions delete their transducer arguments</td> 
      <td>Functions modify their calling object and do not change 
      their arguments (unless otherwise said)</td>
      </tr>
      <tr>
      <td>No unknown or identity symbols</td>
      <td>Unknown and identity symbols are supported 
      in all implementation formats</td>
      </tr>
      </table> 

      <BR></BR>	

   */


  /** \page InstallHfst.html

      <b>This page is still under construction...</b>

      \section installing_library Installing the HFST API library
      
      You can download the source code packet hfst-3.0.tar.gz from the sourceforge
      <a href="http://sourceforge.net/projects/hfst/files/hfst/">download page</a>.
      Extract all files with the command

\verbatim
tar -xzvf hfst-3.0.tar.gz
\endverbatim

      move to directory hfst-3.0 and run the commands

\verbatim
autoreconf -i && ./configure && make && make install
\endverbatim

      To successfully use the HFST library, you should have at least one 
      of the backend libraries
      (<a href="http://www.ims.uni-stuttgart.de/projekte/gramotron/SOFTWARE/SFST.html">SFST</a> 
      (version 1.4.2), 
      <a href="http:://www.openfst.org">OpenFst</a> (version 1.2.6) or 
      <a href="http://foma.sourceforge.net/">foma</a> (version 0.9.13) ) 
      installed on your computer. The in-built HfstTransitionGraph format
      is very limited in its operations and used mainly for conversion 
      between different binary and text formats. The HFST optimized lookup
      transducer format also comes with the source code,
      but it has also a very limited selection of operations 
      as its main purpose is fast lookup of strings.
      By default, the configure script will make HFST compile the interface
      with all the backend implementations that are available on the computer.
      If you do not want an implementation, you can specify it 
      with configure options. For example

\verbatim
./configure --with-sfst=false
\endverbatim

      will exclude the SFST implementation. If the implementation is requested 

\verbatim
HfstTransducer tr("a", "b", SFST_TYPE);
\endverbatim

      an hfst::exceptions::ImplementationTypeNotAvailableException is thrown.

      The command make will compile all the API and commandline tools and install
      will install them to /usr/local. If you would rather install in eg. your home directory, 
      you can tell ./configure:

\verbatim
./configure --prefix=${HOME}
\endverbatim

      If you want to compile or install just the API library without the
      commandline tools, ... ?
      
      */


  /** \page AddingYourLibrary.html 

      <b>This page is still under construction...</b>

      <H2>Adding your own library under the HFST interface</H2>

      There is a very simple transducer library 
      My Finite-State Transducer Library - MFSTL in directory new_library.
      The library defines a transducer class MyFst that contains some functions
      written in namespace mfstl. MFSTL is not meant to be used 
      as a backend implementation but to give an example of how you can
       add your own transducer library under HFST.      

      If you want to install MFSTL, go to directory new_library and 
      run the commands:

\verbatim      
      make && make libinstall
\endverbatim

      By default the MFSTL library is not installed or linked to HFST.
      If you want to use MFSTL, go to the directory where you have your 
      copy of HFST and run the command:

\verbatim
      ./configure --with-mfstl=true
\endverbatim

      <BR></BR>	
      <H2>Configuring</H2>

      In the file configure.ac there are the following lines of code 
      that take care of linking
      to the MFSTL library if the user wants to use it:

\verbatim
AC_ARG_WITH([mfstl],
            [AS_HELP_STRING([--with-mfstl],
                            [process unweighted fsts with mfstl @<:@default=no@:>@])],
            [],
            [with_mfstl=no])
AS_IF([test "x$with_mfstl" != xno], [AC_DEFINE([HAVE_MFSTL], [1],
                                              [Define to compile MFSTL support in HFST])])
AM_CONDITIONAL([WANT_MFSTL], [test x$with_mfstl != xno])

...

if test "x$with_mfstl" != "xno"; then
   AC_CHECK_LIB([mfstl], [main], [],
   		[AC_MSG_FAILURE([mfstl test failed (--without-mfstl to disable)])])
fi

...

if test "x$with_mfstl" != "xno"; then
    AC_CHECK_HEADERS([mfstl/MyFst.h])
fi

...

    *         with mfstl: $with_mfstl
\endverbatim

      When adding your own library you should write the same 
      definitions and tests in file
      configure.ac for your library.

      <BR></BR>
      <H2>Interaction between HFST and your library</H2>

      There are files MfstlTransducer.h and MfstlTransducer.cc in directory
      libhfst/src/implementations. These files form a bridge between 
      MFSTL and HFST libraries.
      They define classes that are needed in cooperation between 
      MFSTL and HFST: 
      MfstlTransducer, MfstlInputStream and MfstlOutputStream. 
      Class MfstlTransducer contains
      static functions that operate on MyFsts, for instance:

\verbatim
    class MfstlTransducer {
      public:

      /** @brief Create a transducer that recognises the symbol pair isymbol:osymbol */
        static MyFst * define_transducer(const char *isymbol, const char *osymbol);

      /** @brief Create a deep copy of transducer t. */
        static MyFst * copy(MyFst * t);

      /** @brief Create a transducer that accepts any number of consecutive string pairs accepted by transducer t. */
        static MyFst * repeat_star(MyFst * t);

      /** @brief Create a transducer that accepts string pair string1:string3 iff t1 accepts string pair string1:string2
	  and t2 accepts string pair string2:string3, where string2 is any string. */
        static MyFst * compose(MyFst * t1, MyFst * t2);

      /** @brief Whether transducers t1 an t2 are equivalent. */
        static bool are_equivalent(MyFst * t1, MyFst * t2);

      /** @brief The number of states in transducer t. */
        static unsigned int number_of_states(MyFst *t);

      ...
    };
\endverbatim

      Classes MfstlInputStream and MfstlOutputStream represent 
      input and output streams 
      to files or standard streams. They are used for reading or writing 
      MyFst binary transducers to/from streams,
      for example:

\verbatim
  class MfstlInputStream  {
    public:
      /** @brief Create and open a stream to file filename. */
      MfstlInputStream(const char * filename);
      /** @brief Whether the stream is at end. */
      bool is_eof(void);
      /** @brief Extract a char from the stream. */
      char stream_get();
      /** @brief Put back a char to the stream. */
      void stream_unget(char c);
      /** @brief Read a MyFst from the stream. */
      MyFst * read_transducer();    
      ...
  };

  class MfstlOutputStream {
    public:
      /** @brief Create and open a stream to standard out. */
      MfstlOutputStream(void); 
      /** @brief Create and open a stream to file filename. */
      MfstlOutputStream(const char * filename);
      /** @brief Write a char to the stream. */
      void write(const char &c);
      /** @brief Write a MyFst to the stream. */
      void write_transducer(MyFst * transducer);
      ...
  };
\endverbatim

	Since MFSTL has only few functionalities, most implementations 
	of functions defined in file MfstlTransducer.h
        return a hfst::exceptions::FunctionNotImplementedError. 
	This is also the way how you probably should begin
	to write your implementation. 

	Conversion from MFSTL to internal transducer format and 
	vice versa are defined
	in files ConvertTransducerFormat.h and ConvertTransducerFormat.cc 
	in directory libhfst/src/implementations.
	Add also your own conversion functions here.	

	MFSTL is handled in the Makefiles of directories libhfst/src/ 
	and libhfst/src/implementations/.
	The former has the following lines:

\verbatim
HFST_HDRS = \
        HfstTransducer.h apply_schemas.h HfstDataTypes.h SymbolDefs.h \
        implementations/ConvertTransducerFormat.h \
        implementations/SfstTransducer.h implementations/TropicalWeightTransducer.h \
        implementations/LogWeightTransducer.h implementations/FomaTransducer.h \
	implementations/HfstOlTransducer.h \	      
        implementations/MfstlTransducer.h \
        HfstAlphabet.h HfstTokenizer.h \
        HfstExceptions.h FlagDiacritics.h HfstInputStream.h HfstOutputStream.h
\endverbatim

      You should add your header file (file that corresponds to MfstlTransducer.h)
      to HFST_HDRS.

      In file libhfst/src/implementations/Makefile.am there are the following lines
      that refer to the MFSTL library:

\verbatim
if WANT_MFSTL
MAYBE_MFSTL=MfstlTransducer.cc
endif

...

BRIDGE_SRCS=$(MAYBE_SFST) $(MAYBE_OPENFST) $(MAYBE_FOMA) $(MAYBE_MFSTL) $(MAYBE_HFSTOL)

...

if WANT_MFSTL
MFSTL_TSTS=MfstlTransducer
endif
check_PROGRAMS=ConvertTransducerFormat HfstInternalTransducer \
			   $(FOMA_TSTS) $(HFSTOL_TSTS) $(OFST_TSTS) $(SFST_TSTS) \
			   $(MFSTL_TSTS)

...

TESTS=ConvertTransducerFormat HfstInternalTransducer \
	  $(FOMA_TSTS) $(HFSTOL_TSTS) $(OFST_TSTS) $(SFST_TSTS) $(MFSTL_TSTS)
\endverbatim

      You should handle your library in the Makefile similarly.

      <BR></BR>
      <H2>Adding your library as a part of the HFST interface</H2>

      HFST must be aware of a new transducer type. In file HfstDataTypes.h
      there is defined an enum ImplementationType where a new enumerator 
      MFSTL_TYPE is be added:

\verbatim
MFSTL_TYPE
\endverbatim

        Some changes must be done in file HfstTransducer.h. 
	The new library header file
	must be included:

\verbatim
#if HAVE_MFSTL
#include "implementations/MfstlTransducer.h"
#endif

...

\verbatim
#if HAVE_MFSTL
  using hfst::implementations::MfstlTransducer;
#endif
\endverbatim

     union TransducerImplementation has a new enumerator:

\verbatim
#if HAVE_MFSTL
  hfst::implementations::MfstlTransducer * mfstl;
#endif
\endverbatim

    An interface through which the backend library can be accessed:

\verbatim
#if HAVE_MFSTL
    static hfst::implementations::MfstlTransducer mfstl_interface;
#endif
\endverbatim


	The unions StreamImplementation in files HfstInputStream.h 
	and HfstOutputStream.h
	have a new enumerator:

\verbatim
#if HAVE_MFSTL
      hfst::implementations::MfstlOutputStream * mfstl;
#endif
\endverbatim

\verbatim
#if HAVE_MFSTL
      hfst::implementations::MfstlInputStream * mfstl;
#endif
\endverbatim

	enum TransducerType in file HfstInputStream.h also has a new enumerator:

\verbatim
MFSTL_
\endverbatim


    The following addition must be done to file HfstTransducer.cc:

\verbatim
#if HAVE_MFSTL
  hfst::implementations::MfstlTransducer MfstlTransducer::mfstl_interface;
#endif
\endverbatim



    The function append_hfst_header_data in file HfstOutputStream.cc must 
    handle the case
    when we write MFSTL binary transducers and need to have a string 
    in the HFST header
    that identifies the transducer's implementation type:

\verbatim
#if HAVE_MFSTL
      case MFSTL_TYPE:
	type_value=std::string("MFSTL");
	break;
#endif
\endverbatim

Similarly we need to identify an HFST binary transducer in MFSTL binary format
from the HFST header:

\verbatim
#if HAVE_MFSTL
    else if (strcmp("MFSTL", header_data[1].second.c_str()) == 0 )
      type = MFSTL_TYPE;
#endif
\endverbatim

	Function guess_fst_type in file HfstInputStream.cc tries to 
	guess what is the format
	of the next transducer in an input stream. We suppose that 
	the first char in a MyFst is 'm'.
	You must of course replace 'm' with the first char in 
	your binary transducer format.
	If the first char is not enough to recognize the transducer type,
	you must
	extract more chars and put them back to the stream. See for example 
	how an
	OpenFst transducer is recognized.

\verbatim
#ifdef HAVE_MFSTL
	/* We suppose that the first char in a MyFst is 'm'. */
	  case 'm':  // Mfstl
	    return MFSTL_;
	    break;
#endif
\endverbatim


      You must also add a separate case for each function in classes 
      HfstTransducer, HfstOutputStream
      and HfstInputStream where your own function is called if the 
      ImplementationType requires it.
      An example from file HfstTransducer.cc:

\verbatim
HfstTransducer::HfstTransducer(const std::string &isymbol, const std::string &osymbol, ImplementationType type):
  type(type),anonymous(false),is_trie(false), name("")
  {
    if (not is_implementation_type_available(type))
      throw hfst::exceptions::ImplementationTypeNotAvailableException();

    switch (this->type)
      {
#if HAVE_SFST
      case SFST_TYPE:
	implementation.sfst = sfst_interface.define_transducer(isymbol.c_str(), osymbol.c_str());
	break;
#endif
#if HAVE_OPENFST
      case TROPICAL_OFST_TYPE:
	implementation.tropical_ofst = tropical_ofst_interface.define_transducer(isymbol, osymbol);
	this->type = TROPICAL_OFST_TYPE;
	break;
      case LOG_OFST_TYPE:
	implementation.log_ofst = log_ofst_interface.define_transducer(isymbol, osymbol);
	break;
#endif
#if HAVE_FOMA
      case FOMA_TYPE:
	implementation.foma = foma_interface.define_transducer( strdup(isymbol.c_str()), strdup(osymbol.c_str()) );
	break;
#endif
#if HAVE_MFSTL
      case MFSTL_TYPE:
	implementation.mfstl = mfstl_interface.define_transducer( isymbol, osymbol );
	break;
#endif
      case ERROR_TYPE:
      default:
	throw hfst::exceptions::TransducerHasWrongTypeException();
	break;
      }
  }
\endverbatim

	You must also modify files apply_schemas.h and HfstApply.cc 
	in the same way.
	Many functions in HfstTransducer.cc call a function defined in 
	apply_schemas.h.
	The functions take as their arguments function pointers 
	to the backend libraries.
	For example the determinization function

\verbatim
HfstTransducer &HfstTransducer::determinize()
  { is_trie = false;
    return apply(
#if HAVE_SFST
       &hfst::implementations::SfstTransducer::determinize,
#endif
#if HAVE_OPENFST
       &hfst::implementations::TropicalWeightTransducer::determinize,
       &hfst::implementations::LogWeightTransducer::determinize,
#endif
#if HAVE_FOMA
       &hfst::implementations::FomaTransducer::determinize,
#endif
#if HAVE_MFSTL
       &hfst::implementations::MfstlTransducer::determinize,
#endif
       false ); } 
\endverbatim

	calls the function

\verbatim
HfstTransducer &apply(
#if HAVE_SFST
 SFST::Transducer * (*sfst_funct)(SFST::Transducer *),
#endif
#if HAVE_OPENFST
 fst::StdVectorFst * (*tropical_ofst_funct)(fst::StdVectorFst *),
 hfst::implementations::LogFst * (*log_ofst_funct)(hfst::implementations::LogFst *),
#endif
#if HAVE_FOMA
 fsm * (*foma_funct)(fsm *),
#endif
#if HAVE_MFSTL
 mfstl::MyFst * (*mfstl_funct)(mfstl::MyFst *),
#endif
 bool dummy /* makes sure there is always a parameter after the function pointer parameters,
	     * so commas between parameters are easier to handle */
);  
\endverbatim

   */

namespace hfst {

  /** \page QuickStart.html

      <b>This page is still under construction...</b>


      \section using_hfst Using HFST in your own code

      After <a href="InstallHfst.html">installing</a> HFST to your computer,
      include file HfstTransducer.h to the beginning of your program file and link to the
      HFST library.

      For example, if you have SFST installed on your computer, the following simple program
      named test.cc
\verbatim
#include <cstdio>
#include "HfstTransducer.h"

int main() 
{
  hfst::HfstTransducer tr1("foo", "bar", SFST_TYPE);
  hfst::HfstTransducer tr2("bar", "baz", SFST_TYPE);
  tr1.compose(tr2);
  tr1.write_in_att_format(stdout);
}
\endverbatim

compiled with the command (this may vary on different computers)

\verbatim
gcc test.cc -lhfst -o test
\endverbatim

should print to standard out the following text when run:

\verbatim
0      1     foo    baz
1
\endverbatim


      \section hfst_structure Structure of the API

The HFST API is written in the namespace #hfst that contains the following classes:

   - HfstTransducer: A class for creating transducers and performing operations on them.

   - HfstInputStream and HfstOutputStream: Classes for writing and reading binary transducers.

   - implementations::HfstTransitionGraph: Class for creating transducers from scratch and iterating through their states and transitions.

   - HfstTokenizer: A class used in creating transducers from UTF-8 strings.

   - HfstGrammar: A class used in \link HfstTransducer::compose_intersect intersecting composition\endlink.

and the following namespaces:

   - \link hfst::rules rules\endlink: A namespace that contains functions to create two-level, replace, restriction and coercion rules.

   - \link hfst::exceptions exceptions\endlink: A namespace for exceptions.


   \section hfst_examples Examples of HFST functionalities

   ...
\verbatim

\endverbatim
      
   */

}

/** \mainpage 

<b>This page is still under construction...</b>

HFST - The Helsinki Finite-State Transducer technology is intended for creating and 
manipulating weighted or unweighted synchronic transducers implementing regular relations.
UTF-8 is chosen as the character encoding used in the HFST software.
Currently HFST has been implemented using the
<a href="http://www.ims.uni-stuttgart.de/projekte/gramotron/SOFTWARE/SFST.html">SFST</a>, 
<a href="http:://www.openfst.org">OpenFst</a> and 
<a href="http://foma.sourceforge.net/">foma</a> software libraries.
Other versions may be added in some future release. 
SFST and foma implementations are unweighted and OpenFst implementation is weighted.

Some of the HFST interface functionalities have also been implemented for 
HFST's own two transducer formats, HfstTransitionGraph and optimized lookup format.
The previous is useful for converting between transducer formats and storing transducers
in an implementation-independent format. The latter is used for fast lookup
of strings in a transducer.

All implementations work according to the same interface, so it is possible
to compile the same piece of code using different backend libraries.
It is also possible to <a href="AddingYourLibrary.html">add</a> 
your own transducer library under the HFST interface.

The examples given in this documentation use 
<a href="http://www.xrce.xerox.com/print/Research-Development/Publications/1997-0052">Xerox transducer notation</a>.
<!-- More info on SFST tools is in http://www.ims.uni-stuttgart.de/projekte/gramotron/SOFTWARE/SFST.html,
OpenFst in http://www.openfst.org and foma in http://www.aclweb.org/anthology/E/E09/E09-2008.pdf. -->

<br></br>

\section what_is_new What is new in version 3.0

   - A third transducer library, <a href="http://foma.sourceforge.net/">foma</a>, is included

   - <a href="AddingYourLibrary.html">Adding</a> your own transducer library under the HFST interface is easy

   - Unknown and identity \link hfst::String symbols\endlink are supported


\section features Features

   - Create transducers \link hfst::implementations::HfstTransitionGraph from scratch\endlink

   - \link hfst::implementations::HfstTransitionGraph::iterator Iterate\endlink through a transducer's states and transitions

   - Create transducers by \link hfst::HfstTokenizer tokenizing\endlink UTF-8 strings with multicharacter symbols

   - Apply two-level, replace, restriction and coercion \link hfst::rules rules\endlink


\section tutorial Tutorial

   - A <a href="QuickStart.html">quick start</a> to the HFST interface with examples

   - <a href="AddingYourLibrary.html">Adding</a> your own implementation of HFST

   - <a href="VersionDifferences.html">Differences</a> between HFST version 2 and 3


\section download_hfst Download

   - <a href="http://sourceforge.net/projects/hfst/files/hfst">Download</a> and 
   <a href="InstallHfst.html">install</a> the HFST interface and commandline tools


\section links Links

   - <a href="https://kitwiki.csc.fi/twiki/bin/view/KitWiki/HfstOutline">Examples</a> of programs implemented using the HFST interface

   - <a href="https://kitwiki.csc.fi/twiki/bin/view/KitWiki/HfstHome">Documentation</a> of the HFST project

   <br></br>

*/

/** 
    @dir libhfst/src 
    @brief A directory for the HFST interface. 
*/

/** 
    @dir libhfst/src/implementations 
    @brief A directory for the different backend implementations.
    
    The files in this directory act as a bridge between the HFST
    interface and the backend libraries.
    Basicly this directory contains two files per implementation,
    for example the files SfstTransducer.h and SfstTransducer.cc 
    define the SFST implementation. 
*/
 