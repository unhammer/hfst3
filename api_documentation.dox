
  /** \page VersionDifferences.html 

      <b>This page is still under construction...</b>

      If you need documentation on HFST version 2, you find it 
      <a href="http://hfst.sourceforge.net/hfst2/index.html">here</a>.
      The page is no longer updated and it is recommended to update
      to version 3.0.

      Some changes from version 2 to 3:

      <table>
      <tr>
      <th>HFST version 2</th>
      <th>HFST version 3</th>
      </tr>
      <tr>  
      <td>Namespaces HFST and HWFST</td>
      <td>Namespace #hfst and an 
      \link hfst::ImplementationType ImplementationType\endlink argument</td>
      </tr>
      <tr>
      <td>KeyLayer and SymbolLayer</td>
      <td>Functions take a \link hfst::String String\endlink argument, 
      string-to-number mapping
      is done internally and automatically</td>
      </tr>
      <tr>
      <td>TransducerLayer, Rule Layer, CoreExtensionLayer</td>	
      <td>\link hfst::HfstTransducer HfstTransducer\endlink, 
      namespace \link hfst::rules rules\endlink, 
      class \link hfst::implementations::HfstTransitionGraph HfstTransitionGraph\endlink</td>
      </tr>
      <tr>
      <td>Functions delete their transducer arguments</td> 
      <td>Functions modify their calling object and do not change 
      their arguments (unless otherwise said)</td>
      </tr>
      <tr>
      <td>No unknown or identity symbols</td>
      <td>Unknown and identity \link hfst::String symbols\endlink are supported 
      in all implementation formats</td>
      </tr>
      </table> 

      <BR>	

   */


  /** \page InstallHfst.html

      <b>This page is still under construction...</b>

      \section installing_library Installing the HFST API library
      
      You can download the source code packet hfst-3.0.tar.gz
      (will be published during January 2011) from the sourceforge
      <a href="http://sourceforge.net/projects/hfst/files/hfst/">download page</a>.
      Extract all files with the command

\verbatim
tar -xzvf hfst-3.0.tar.gz
\endverbatim

      move to directory hfst-3.0 and run the commands

\verbatim
autoreconf -i && ./configure && make && make install
\endverbatim

      To successfully use the HFST library, you should have at least one 
      of the backend libraries
      (<a href="http://www.ims.uni-stuttgart.de/projekte/gramotron/SOFTWARE/SFST.html">SFST</a> 
      (version 1.4.2), 
      <a href="http:://www.openfst.org">OpenFst</a> (version 1.2.6) or 
      <a href="http://foma.sourceforge.net/">foma</a> (version 0.9.13) ) 
      installed on your computer. The in-built HfstTransitionGraph format
      is very limited in its operations and used mainly for conversion 
      between different binary and text formats. The HFST optimized lookup
      transducer format also comes with the source code,
      but it has also a very limited selection of operations 
      as its main purpose is fast lookup of strings.
      By default, the configure script will make HFST compile the interface
      with all the backend implementations that are available on the computer.
      If you do not want an implementation, you can specify it 
      with configure options. For example

\verbatim
./configure --with-sfst=false
\endverbatim

      will exclude the SFST implementation. If the implementation is requested 

\verbatim
HfstTransducer tr("a", "b", SFST_TYPE);
\endverbatim

      an hfst::exceptions::ImplementationTypeNotAvailableException is thrown.

      The command make will compile all the API and commandline tools and install
      will install them to /usr/local. If you would rather install in eg. your home directory, 
      you can tell ./configure:

\verbatim
./configure --prefix=${HOME}
\endverbatim

      <!-- If you want to compile or install just the API library without the
      commandline tools -->
      
      */


  /** \page AddingYourLibrary.html 

      <b>This page is still under construction...</b>

      <H2>Adding your own library under the HFST interface</H2>

      When adding your library under HFST, you must do some modifications 
      to the HFST files.
      The places where you must make modifications, i.e. add your own code,
      are marked in the files inside comments.

      <H2>Configuring</H2>

      The configuration file must be aware of the new library.
      You have to add the following pieces of code to the file configure.ac
      (change "MY_TRANSDUCER_LIBRARY" etc. to the name of your transducer library):

      \verbatim
AC_ARG_WITH([my_transducer_library],
            [AS_HELP_STRING([--with-my-transducer-library],
                            [process unweighted fsts with my transducer library @<:@default=no@:>@])],
            [],
            [with_my_transducer_library=no])
AS_IF([test "x$with_my_transducer_library" != xno], [AC_DEFINE([HAVE_MY_TRANSDUCER_LIBRARY], [1],
                                              [Define to compile my transducer library support in HFST])])
AM_CONDITIONAL([WANT_MY_TRANSDUCER_LIBRARY], [test x$with_my_transducer_library != xno])
      \endverbatim

      \verbatim
AS_IF([test "x$with_my_transducer_library" != "xno"],
      [AC_CHECK_LIB([my_transducer_library], [main], [],
                [AC_MSG_FAILURE([my transducer library test failed (--without-my-transducer-library to disable)])])])
      \endverbatim

      \verbatim
AS_IF([test "x$with_my_transducer_library" != "xno"],
      [AC_CHECK_HEADERS([my_transducer_library/MyTransducerLibrary.h])])
      \endverbatim

      \verbatim
    *         with my transducer library: $with_my_transducer_library
     \endverbatim

     <BR>

     <H2>The interaction between HFST and your library</H2>

     In directory libhfst/src/implementations there are skeleton files
     MyTransducerLibraryTransducer.h and MyTransducerLibraryTransducer.cc.
     These files define <a href="group__AddingLibrary.html">a group of static classes</a>
     MyTransducerLibraryTransducer, MyTransducerLibraryInputStream
     and MyTransducerLibraryOutputStream that
     contain functions that operate on transducers and streams.
     These classes act as an interface between HFST and your library.
     The HFST interface will access your library through these classes.
     These are the files where you should write your implementations.
     The assumption is that most of the functionalities are found already in your library
     and you just have to modify them a little so that thay can be accessed 
     via a standardized interface that works similarily for all implementations.

     All functions return an hfst::exceptions::FunctionNotImplementedException
     as they have no implementation. When starting to add your own implementations,
     you can also return the same exception for all functions that you have not 
     yet implemented.

     In the same directory there are files
     ConvertTransducerFormat.h ConvertTransducerFormat.cc
     that contain functions that convert between HFST's own transducer format,
     hfst::implementations::HfstBasicTransducer, and the transducer formats 
     of different implementations. Add here functions that convert between 
     HfstBasicTransducer and your transducer class (change MyFst to the name of 
     your transducer class, my_namespace to the namespace where it is written and
     "my_transducer_library" to the name of your transducer library 
     or some other descriptive name):

\verbatim
  #if HAVE_MY_TRANSDUCER_LIBRARY
  static HfstBasicTransducer * 
    my_transducer_library_transducer_to_hfst_basic_transducer
      (my_namespace::MyFst * t);
  
  static my_namespace::MyFst * 
    hfst_basic_transducer_to_my_transducer_library_transducer
      (const HfstBasicTransducer * t);
  #endif // HAVE_MY_TRANSDUCER_LIBRARY
\endverbatim

Add also the following lines to libhfst/src/implementations/Makefile.am:

\verbatim
if WANT_MY_TRANSDUCER_LIBRARY
MAYBE_MY_TRANSDUCER_LIBRARY=MyTransducerLibraryTransducer.cc
endif
\endverbatim

and the variable <CODE>$(MAYBE_MY_TRANSDUCER_LIBRARY)</CODE> to the list
of source files:

\verbatim
BRIDGE_SRCS=$(MAYBE_SFST) $(MAYBE_OPENFST) $(MAYBE_FOMA) $(MAYBE_HFSTOL) # $(MAYBE_MY_TRANSDUCER_LIBRARY)
\endverbatim

     <BR>


     <H2>Using your implementation in HFST</H2>

     HfstDataTypes.h

     enum ImplementationType needs a new enumerator):

\verbatim
     MY_TRANSDUCER_LIBRARY_TYPE, 
\endverbatim

     In file HfstTransducer.h:

\verbatim
/* Include here the header file of the files that take care 
   of the interaction between HFST and your transducer library. */
//#if HAVE_MY_TRANSDUCER_LIBRARY
//#include "implementations/MyTransducerLibraryTransducer.h"
//#endif

  /* Add here the transducer class of your transducer library. */
  //#if HAVE_MY_TRANSDUCER_LIBRARY
  //  using hfst::implementations::MyTransducerLibraryTransducer;
  //#endif // #if HAVE_MY_TRANSDUCER_LIBRARY
\endverbatim


The transducer class of your library.	
  This is the only thing that HFST is aware of in your library.
All other functionalities are accessed through classes MyTransducerLibraryTransducer,
MyTransducerLibraryInputStream and MyTransducerLibraryOutputStream.

\verbatim
      /* Add here your own transducer backend implementation. */
      //#if HAVE_MY_TRANSDUCER_LIBRARY
      //      hfst::implementations::MyFst * my_transducer_library;
      //#endif

    /* Add here an interface that takes care of the interaction between
       HFST and your transducer library. */
    //#if HAVE_MY_TRANSDUCER_LIBRARY
    //static hfst::implementations::MyTransducerLibraryTransducer
    //  my_transducer_library_interface;
    //#endif
\endverbatim

    HfstTransducer.cc, HfstInputStream.h, HfstOutputStream.h,
    HfstInputStream.cc, HfstOutputStream.cc.

    hfst_apply_schemas.h, HfstApply.cc

    libhfst/src/Makefile.am the list HFST_HDRS:

\verbatim
### Add your library here ###
#	implementations/MyTransducerLibraryTransducer.h
\endverbatim

   */

namespace hfst {

  /** \page QuickStart.html

      <b>This page is still under construction...</b>


      \section using_hfst Using HFST in your own code

      After <a href="InstallHfst.html">installing</a> HFST to your computer,
      include file HfstTransducer.h to the beginning of your program file and link to the
      HFST library.

      For example, if you have SFST installed on your computer, the following simple program
      named test.cc
\verbatim
#include <cstdio>
#include "HfstTransducer.h"

using namespace hfst;

int main() 
{
  HfstTransducer tr1("foo", "bar", SFST_TYPE);
  HfstTransducer tr2("bar", "baz", SFST_TYPE);
  tr1.compose(tr2);
  tr1.write_in_att_format(stdout);
}
\endverbatim

compiled with the command (this may vary on different computers)

\verbatim
gcc test.cc -lhfst -o test
\endverbatim

should print to standard out the following text when run:

\verbatim
0      1     foo    baz
1
\endverbatim

<BR>

      \section hfst_structure Structure of the API

The HFST API is written in the namespace #hfst that includes the following classes:

   - HfstTransducer: A class for creating transducers and performing operations on them.

   - HfstInputStream and HfstOutputStream: Classes for writing and reading binary transducers.

   - implementations::HfstTransitionGraph: A class for creating transducers from scratch and iterating through their states and transitions.

   - HfstTokenizer: A class used in creating transducers from UTF-8 strings.

and the following namespaces:

   - \link hfst::rules rules\endlink: A namespace that contains functions to create two-level, replace, restriction and coercion rules.

   - \link hfst::exceptions exceptions\endlink: A namespace for exceptions.

   - \link hfst::implementations implementations\endlink: A namespace that contains HFST's own transducer format.

<BR>

   \section hfst_examples Examples of HFST functionalities

   An example of creating a simple transducer from scratch
   and converting between transducer formats and testing
   transducer properties and handling exceptions:

\verbatim
using namespace hfst;
using implementations::HfstBasicTransducer;
using implementations::HfstBasicTransition;

/* Create a HFST basic transducer [a:b] with transition weight 0.3 and 
   final weight 0.5. */
HfstBasicTransducer t;
t.add_state(1);
t.add_transition(0, HfstBasicTransition(1, "a", "b", 0.3));
t.set_final_weight(1, 0.5);

/* Convert to tropical OpenFst format and push weights 
   toward final state. */
HfstTransducer T(t, TROPICAL_OFST_TYPE);
T.push_weights(TO_FINAL_STATE);

/* Convert back to HFST basic transducer. */
HfstBasicTransducer tc(T);
try {
  /* Rounding might affect the precision. */  
  if (0.79 < tc.get_final_weight(1) &&
      tc.get_final_weight(1) < 0.81) {
      fprintf(stderr, "TEST OK\n");
      exit(0);
  }
  fprintf(stderr, "TEST FAILED\n");
  exit(1);
} 
/* If the state does not exist or is not final */
catch (exceptions::HfstInterfaceException e) {
  fprintf(stderr, "TEST FAILED: An exception thrown.\n");
  exit(1);
}
\endverbatim


An example of creating transducers from strings, applying rules to them
an printing the resulting transducer.

\verbatim
  using namespace hfst;

  ImplementationType type=FOMA_TYPE;

  /* Create a simple lexicon transducer 
     [[foo bar foo] | [foo bar baz]]. */

  HfstTokenizer tok;
  tok.add_multichar_symbol("foo");
  tok.add_multichar_symbol("bar");
  tok.add_multichar_symbol("baz");
  
  HfstTransducer words("foobarfoo", tok, type);
  HfstTransducer t("foobarbaz", tok, type);
  words.disjunct(t);

  
  /* Create a rule transducer that optionally replaces 
     "bar" with "baz" between "foo" and "foo". */

  HfstTransducerPair context
    (HfstTransducer("foo", type),
     HfstTransducer("foo", type) );
  HfstTransducer mapping
    ("bar", "baz", type);
  bool optional=true;
  
  StringPairSet alphabet;
  alphabet.insert(StringPair("foo", "foo"));
  alphabet.insert(StringPair("bar", "bar"));
  alphabet.insert(StringPair("baz", "baz"));
  
  HfstTransducer rule = rules::replace_up
    (context, mapping, optional, alphabet);


  /* Apply the rule transducer to the lexicon. */  
  words.compose(rule);
  
  
  /* Extract all string pairs from the result and print
     them to stdout. */

  WeightedPaths<float>::Set results;
  
  try {
    words.extract_strings(results);
  } 
  catch (hfst::exceptions::TransducerIsCyclicException e)
    {
      /* This should not happen because transducer is not cyclic. */
      fprintf(stderr, "TEST FAILED\n");
      exit(1);
    }

  for (WeightedPaths<float>::Set::const_iterator it = results.begin();
         it != results.end(); it++)
    {
    fprintf(stdout, "%s : %s\n", 
            it->istring.c_str(), 
            it->ostring.c_str());
    }
\endverbatim

An example of reading binary transducers from stdin,
converting them to SFST format and writing them to stdout
and in AT&T format to file "testfile.att":

\verbatim
  HfstInputStream in;
  HfstOutputStream out(SFST_TYPE);
  FILE * file = fopen("testfile.att", "wb");
  bool first_transducer=true;

  while (not in.is_eof()) 
  {
    if (not first_transducer)
      fprintf(file, "--\n"); /* AT&T format separator. */
    HfstTransducer t(in);
    HfstTransducer tc(t, SFST_TYPE);
    out << tc;
    tc.write_in_att_format(file);
    first_transducer=false;
  }
  in.close();
  out.close();
  fclose(file);
\endverbatim

<BR>
      
   */

}

/** \mainpage 

<b>This page is still under construction...</b>

HFST - The Helsinki Finite-State Transducer technology is intended for creating and 
manipulating weighted or unweighted synchronic transducers implementing regular relations.
UTF-8 is chosen as the character encoding used in the HFST software.
Currently HFST has been implemented using the
<a href="http://www.ims.uni-stuttgart.de/projekte/gramotron/SOFTWARE/SFST.html">SFST</a>, 
<a href="http:://www.openfst.org">OpenFst</a> and 
<a href="http://foma.sourceforge.net/">foma</a> software libraries.
Other versions may be added in some future release. 
SFST and foma implementations are unweighted and OpenFst implementation is weighted.

Some of the HFST interface functionalities have also been implemented for 
HFST's own two transducer formats, HfstTransitionGraph and optimized lookup format.
The previous is useful for converting between transducer formats and storing transducers
in an implementation-independent format. The latter is used for fast lookup
of strings in a transducer.

All implementations work according to the same interface, so it is possible
to compile the same piece of code using different backend libraries.
It is also possible to <a href="AddingYourLibrary.html">add</a> 
your own transducer library under the HFST interface.

The examples given in this documentation use 
<a href="http://www.xrce.xerox.com/print/Research-Development/Publications/1997-0052">Xerox transducer notation</a>.

<br>

\section what_is_new What is new in version 3.0

   - A third transducer library, <a href="http://foma.sourceforge.net/">foma</a>, is included

   - <a href="AddingYourLibrary.html">Adding</a> your own transducer library under the HFST interface is easy

   - Unknown and identity \link hfst::String symbols\endlink are supported


\section features Features

   - Create transducers \link hfst::implementations::HfstTransitionGraph from scratch\endlink

   - \link hfst::implementations::HfstTransitionGraph::iterator Iterate\endlink through a transducer's states and transitions

   - Create transducers by \link hfst::HfstTokenizer tokenizing\endlink UTF-8 strings with multicharacter symbols

   - Apply two-level, replace, restriction and coercion \link hfst::rules rules\endlink


\section tutorial Tutorial

   - A <a href="QuickStart.html">quick start</a> to the HFST interface with examples

   - <a href="AddingYourLibrary.html">Adding</a> your own implementation of HFST

   - <a href="VersionDifferences.html">Differences</a> between HFST versions 2 and 3


\section download_hfst Download

   - <a href="http://sourceforge.net/projects/hfst/files/hfst">Download</a> and 
   <a href="InstallHfst.html">install</a> the HFST interface and commandline tools


\section links Links

   - <a href="https://kitwiki.csc.fi/twiki/bin/view/KitWiki/HfstOutline">Examples</a> of programs implemented using the HFST interface

   - <a href="https://kitwiki.csc.fi/twiki/bin/view/KitWiki/HfstHome">Documentation</a> of the HFST project

   <br>

*/

/** 
    @dir libhfst/src 
    @brief A directory for the HFST interface. 

    The files in this directory contain the public interface
    of HFST and internal code that is not implementation-specific.
*/

/** 
    @dir libhfst/src/implementations 
    @brief A directory for the different backend implementations.
    
    The files in this directory act as a bridge between the HFST
    interface and the backend libraries.
    Basicly this directory contains two files per implementation,
    for example the files SfstTransducer.h and SfstTransducer.cc 
    define the SFST implementation. 

    What about HFST optimized lookup format?
*/
 