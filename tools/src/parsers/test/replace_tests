regex a -> b || ? - a _ ;
apply up maa
# mba

# empty language replacement
regex a -> ~[?*] == ?*

# empty language replacement
regex ~[?*] -> a == ?*

regex [ d <- ca || ca_c ] ;
apply up cacacac
# cad0d0c

regex [ b <- a ,, a <- b ] ;
apply up abba
# baab

regex ab (->) x  ab_a ;
apply up abababa
# abx0aba
# ababx0a
# abx0x0a

regex ab -> x  ab_a ;
apply up abababa
# abx0x0a

regex a (->) x ;
apply up aaana
# aaana
# aaanx
# aaxna
# aaxnx
# axana
# axanx
# axxna
# axxnx
# xaana
# xaanx
# xaxna
# xaxnx
# xxana
# xxanx
# xxxna
# xxxnx

regex a -> x ;
apply up aaana
# xxxnx

regex a @-> x ;
apply up aaana
# xxxnx

regex a @> x ;
apply up aaana
# xxxnx

regex ? -> x ;
apply up s
# x

regex a -> b || .#. _ c ;
apply up .#.ac
# .#.ac
apply up ac
# ab


input1 = "aaaa"
input2 = "aaaaabaaaa"
input3 = "aaaaabaaaacaaaa"

result1 = aaaa:{aaaa,ax0a,axaa,aaxa,axxa}
result2 = aaaa:{ax0a,axxa}
result3 = aaaa:{ax0a}
result4 = aaaaabaaaa:ax00abax0a
result5 = aaaaabaaaa:axxxabaxxa
result6 = aaaaabaaaacaaaa:ax00abax0acax0a
result7 = aaaaabaaaacaaaa:axxxabaxxacaxxa
result8 = aaaa:{aaaa,ax0a,axaa,aaxa}
result9 = aaaa:{ax0a,axaa}
result10 = aaaa:{ax0a,aaxa}
result11 = aaaa:{ax0a,axaa,aaxa}


regex a+ (->) x || a _ a ;
apply up aaaa
# aaaa
# ax0a
# axaa
# aaxa

regex a+ (->) x // a _ a ;
apply up aaaa
# aaaa
# ax0a
# axaa
# aaxa
# axxa

regex a+ (->) x \\ a _ a ;
apply up aaaa
# aaaa
# ax0a
# axaa
# aaxa
# axxa

regex a+ (->) x \/ a _ a ;
apply up aaaa
# aaaa
# ax0a
# axaa
# aaxa
# axxa

regex a+ -> x || a _ a ;
apply up aaaa
# ax0a
# axxa

regex a+ -> x // a _ a ;
apply up aaaa
# ax0a
# axaa

regex a+ -> x \\ a _ a ;
apply up aaaa
# ax0a
# aaxa

regex a+ -> x \/ a _ a ;
apply up aaaa
# ax0a
# axaa
# aaxa

regex a+ @-> || a _ a ;

regex a+ @> || a _ a ;

replace_leftmost_longest_match UP: input1 -> result3, input2 -> result4, input3 -> result6
replace_leftmost_shortest_match UP: input1 -> result4, input2 -> result5, input3 -> result7

longest & shortest, left & right
regex a+ b+ | b+ a+ @-> x ;
input aabbaa

regex [ a+ b+ | b+ a+ ] -> x ;

input1 = aabbaa
result1 = x000aa
result2 = aax000
result3 = x00x0a
result4 = ac0x00

replace_leftmost_longest_match UP: input1 -> result1
replace_rightmost_longest_match UP: input1 -> result2
replce_leftmost_shortest_match UP: input1 -> result3
replace_rightmost_shortest_match UP: input1 -> result4

regex [ a+ b+ | b+ a+ ] @-> x \/ _ x ;
replace_leftmost_longest_match DOWN: aabbaax -> x00x00x

regex a+ @-> x || c _ ;
replace_leftmost_longest_match UP: caav -> cx0v

regex ? @-> a ... b ;
result: bb -> 0b00b0:abbabb 

regex a (->) b ||  x _ x ;
xaxax:{xaxax,xbxax,xaxbx,xbxb}

regex a b (->) b ||  x_y, y_z ;
axayaz:{axayaz,axbybz,axbyaz,axaybz}

regex a+ (->) x  || x x _ y y, y _ x ;
axxayyaax:{axxayyax,axxayyxx,axxxyyax,axxxyyxx}

regex a (->) b ;
xaxax:{xaxax,xbxax,xaxbx,xbxbx}

regex b -> a  || _a (r: bbaa) ;
regex b -> a  \\ _a (r:aaaa) ;
regex b -> a  _a (r:bbaa) ;
regex b -> a  \/ _a (r:aaaa) ;
input: bbba

regex b -> a  || a _ (r: aabb) ;
regex b -> a  \\ a _ (r: aabb) ;
regex b -> a  a _ (r: aaaa) ;
regex b -> a  \/ a _ (r: aaaa) ;
input: abbb

regex ab -> x || ab _ a (r: result4)
regex ab -> x \\ ab _ a (r: result2)
regex ab -> x ab _ a (r: result3)
regex ab -> x \/ ab _ a (r: result4)
regex ab (->) x || ab _ a (r: result3)
regex ab (->) x \\ ab _ a (r: result2)
regex ab (->) x ab _ a (r: result2)
regex ab (->) x \/ ab _ a (r: result2)
input: abababa
result1 = abababa
result2 = abababa,ababx0a,abx0aba
result3 = abababa,ababx0a,abx0aba,abx0x0a
result4 = ababx0a,abx0aba


regex [a|b] -> "[" ... "]" ;
mba -> m[b][a]

0 -> m ;

a* -> p ;

0 -> b || _ a a

a -> b , b -> c

[. .] -> b , a -> c ;

a+ @-> x , b+ @-> y

a+ @> x , b+ @> y

a+ -> x \/ m _ ,, b+ -> y || x _

a -> x \/ m _ ,, b -> y || x _ ;

0 .o. [ [. 0 .] -> a \/ _ b a , a b _ ,, [. 0 .] -> b \/ a _ a ]

? -> x , a -> b

/* markup vector
void test7e( ImplementationType type )
{
    HfstTokenizer TOK;
    TOK.add_multichar_symbol("@_EPSILON_SYMBOL_@");


    // Mapping

    HfstTransducer leftMapping1("a", TOK, type);
    HfstTransducer leftMapping2("b", TOK, type);
    HfstTransducer empty(type);

    HfstTransducerPair mappingPair1(leftMapping1, empty);
    HfstTransducerPairVector mappingPairVector1;
    mappingPairVector1.push_back(mappingPair1);

    HfstTransducerPair mappingPair2(leftMapping2, empty);
    HfstTransducerPairVector mappingPairVector2;
    mappingPairVector2.push_back(mappingPair2);

    StringPair marks1("[","]");
    StringPair marks2("|","|");


    MarkUpRule markUpRule1(mappingPairVector1, marks1 );
    MarkUpRule markUpRule2(mappingPairVector2, marks2 );

    vector<MarkUpRule> markUpRuleVector;
    markUpRuleVector.push_back(markUpRule1);
    markUpRuleVector.push_back(markUpRule2);

    HfstTransducer input1("ab", TOK, type);

    HfstTransducer result1("@_EPSILON_SYMBOL_@a@_EPSILON_SYMBOL_@@_EPSILON_SYMBOL_@b@_EPSILON_SYMBOL_@",
                    "[a]|b|",TOK, type);


    HfstTransducer replaceTr(type);
    HfstTransducer tmp2(type);

    replaceTr = mark_up_replace( markUpRuleVector, false);

    tmp2 = input1;
    tmp2.compose(replaceTr).minimize();
    //printf("7e: \n");
    //tmp2.write_in_att_format(stdout, 1);
    assert(tmp2.compare(result1));
}
*/


// a -> b , b -> a
void test7f( ImplementationType type )
{
    HfstTokenizer TOK;
    TOK.add_multichar_symbol("@_EPSILON_SYMBOL_@");

    // Mapping

    HfstTransducer leftMapping1("a", TOK, type);
    HfstTransducer rightMapping1("b", TOK, type);
    HfstTransducerPair mappingPair1(leftMapping1, rightMapping1);

    HfstTransducer leftMapping2("b", TOK, type);
    HfstTransducer rightMapping2("a", TOK, type);
    HfstTransducerPair mappingPair2(leftMapping2, rightMapping2);

    HfstTransducerPairVector mappingPairVector1;
    mappingPairVector1.push_back(mappingPair1);

    HfstTransducerPairVector mappingPairVector2;
    mappingPairVector2.push_back(mappingPair2);


    // without context
    Rule rule1(mappingPairVector1);
    Rule rule2(mappingPairVector2);

    vector<Rule> ruleVector;

    ruleVector.push_back(rule1);
    ruleVector.push_back(rule2);


    HfstTransducer input1("aabbaa", TOK, type);
    HfstTransducer result1("aabbaa", "bbaabb",TOK, type);


    HfstTransducer replaceTr(type);
    HfstTransducer tmp2(type);

    replaceTr = replace(ruleVector, false);

    tmp2 = input1;
    tmp2.compose(replaceTr).minimize();
    //printf("Test 7f Replace leftmost tr2: \n");
    //tmp2.write_in_att_format(stdout, 1);
    assert(tmp2.compare(result1));


}



// a -> b b, a -> b
void test7g( ImplementationType type )
{
    HfstTokenizer TOK;
    TOK.add_multichar_symbol("@_EPSILON_SYMBOL_@");

    // Mapping

    HfstTransducer leftMapping1("a", TOK, type);
    HfstTransducer rightMapping1("bb", TOK, type);
    HfstTransducerPair mappingPair1(leftMapping1, rightMapping1);

    HfstTransducer leftMapping2("a", TOK, type);
    HfstTransducer rightMapping2("b", TOK, type);
    HfstTransducerPair mappingPair2(leftMapping2, rightMapping2);


    HfstTransducerPairVector mappingPairVector1;
    mappingPairVector1.push_back(mappingPair1);

    HfstTransducerPairVector mappingPairVector2;
    mappingPairVector2.push_back(mappingPair2);



    // without context
    Rule rule1(mappingPairVector1);
    Rule rule2(mappingPairVector2);

    vector<Rule> ruleVector;

    ruleVector.push_back(rule1);
    ruleVector.push_back(rule2);


    HfstTransducer input1("a", TOK, type);
    HfstTransducer result1("a", "b",TOK, type);
    HfstTransducer resultTmp("a@_EPSILON_SYMBOL_@", "bb",TOK, type);
    result1.disjunct(resultTmp).minimize();

    HfstTransducer replaceTr(type);
    HfstTransducer tmp2(type);

    replaceTr = replace(ruleVector, false);

    tmp2 = input1;
    tmp2.compose(replaceTr).minimize();
    //printf("Test 7f Replace leftmost tr2: \n");
    //tmp2.write_in_att_format(stdout, 1);
    assert(tmp2.compare(result1));
}

//[..] @-> a;
void test7h( ImplementationType type )
{
    HfstTokenizer TOK;
    TOK.add_multichar_symbol("@_EPSILON_SYMBOL_@");
    TOK.add_multichar_symbol("@_IDENTITY_SYMBOL_@");

    // Mapping

    HfstTransducer leftMapping1("@_EPSILON_SYMBOL_@", TOK, type);
    HfstTransducer rightMapping1("a", TOK, type);
    HfstTransducerPair mappingPair1(leftMapping1, rightMapping1);

    HfstTransducerPairVector mappingPairVector1;
    mappingPairVector1.push_back(mappingPair1);

    // without context
    Rule rule(mappingPairVector1);

    HfstTransducer replaceTr(type);
    replaceTr = replace_leftmost_longest_match(rule);


//    printf("replaceTr: \n");
//    replaceTr.write_in_att_format(stdout, 1);

    //result
    /*
    0 1     @0@     a       0.000000
    1 0     @_IDENTITY_SYMBOL_@    @_IDENTITY_SYMBOL_@      0.000000
    1 0     a       a       0.000000
    0 0.000000
     *
     */

    HfstBasicTransducer bt;
    bt.add_transition(0, HfstBasicTransition(1, "@_EPSILON_SYMBOL_@", "a", 0) );
    bt.add_transition(1, HfstBasicTransition(0, "@_IDENTITY_SYMBOL_@", "@_IDENTITY_SYMBOL_@", 0) );
    bt.add_transition(1, HfstBasicTransition(0, "a", "a", 0) );
    bt.set_final_weight(1, 0);

    HfstTransducer result1(bt, type);
//    printf("result1: \n");
//    result1.write_in_att_format(stdout, 1);
    assert(replaceTr.compare(result1));

}
